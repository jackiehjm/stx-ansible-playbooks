---
#
# Copyright (c) 2019-2022 Wind River Systems, Inc.
#
# SPDX-License-Identifier: Apache-2.0
#
# ROLE DESCRIPTION:
#   This role is to restore the remaining data in the backup tarball
#   during platform restore.
#

- name: Set parameters for archive paths
  set_fact:
    archive_platform_conf_path: "{{ platform_conf_path | regex_replace('^\\/', '') }}"
    archive_ceph_backend_flag: "{{ ceph_backend_flag | regex_replace('^\\/', '') }}"
    archive_fernet_keys_permdir: "{{ fernet_keys_permdir | regex_replace('^\\/', '') }}"

# User postgres needs access files in this folder during restore
# Permissions will be set back to 0750 when host is unlocked
- name: Correct staging directory permissions for restore
  file:
    path: "{{ staging_dir }}"
    state: directory
    recurse: yes
    owner: root
    group: root
    mode: 0755

- block:
  # These hieradata were generated after persist-config role was run. They
  # will be re-generated when sysinv is restarted after postgres db is restored
  - name: Remove newly generated hieradata data
    file:
      path: "{{ item }}"
      state: absent
    with_items:
      - "{{ puppet_permdir }}/hieradata/{{ controller_floating_address|ipmath(1) }}.yaml"
      - "{{ puppet_permdir }}/hieradata/system.yaml"
      - "{{ puppet_permdir }}/hieradata/secure_system.yaml"

  - name: Extract platform.conf from the backup tarball
    command: >-
      tar -C {{ staging_dir }} -xpf {{ restore_data_file }}  --transform='s,.*/,,'
      {{ archive_platform_conf_path }}/platform.conf
    args:
      warn: false

  - name: Search for the new INSTALL_UUID in /etc/platform/platform.conf
    shell: grep INSTALL_UUID {{ platform_conf_path }}/platform.conf
    register: result

  - name: Replace INSTALL_UUID with the new one
    lineinfile:
      dest: "{{ staging_dir }}/platform.conf"
      regexp: 'INSTALL_UUID'
      line: "{{ result.stdout }}"

  - name: Strip out entries that are host specific
    lineinfile:
      dest: "{{ staging_dir }}/platform.conf"
      regexp: "{{ item }}"
      state: absent
    with_items:
      - '^oam_interface='
      - '^cluster_host_interface='
      - '^UUID='

  - name: Search for the management_interface in /etc/platform/platform.conf
    shell: grep management_interface {{ platform_conf_path }}/platform.conf
    failed_when: false
    register: result

  - name: Replace management_interface with the new one
    lineinfile:
      dest: "{{ staging_dir }}/platform.conf"
      regexp: '^management_interface='
      line: "{{ result.stdout }}"
    when: result.rc == 0

  - name: Replace platform config file
    command: mv -f {{ staging_dir }}/platform.conf {{ platform_conf_path}}/platform.conf

  when: migrate_platform_data is not defined or not migrate_platform_data

# For subcloud, the DC root CA certificate needs to be restored from backup
# into /opt/platform/config directory and it will be installed to controllers
# at the time when controllers are unlocked.
- block:
  # Restore admin endpoint root CA certificate for DC if it exists in backup
  - name: Check if admin endpoint root CA certficate exists in backup config permdir (opt/platform/config)
    command: >-
      tar -tf {{ restore_data_file }}
      '{{ archive_config_permdir }}/dc-adminep-root-ca.crt'
    register: check_ca_cert
    failed_when: false
    args:
      warn: false

  - name: Restore admin endpoint root CA certificate into config permdir (/opt/platform/config/...)
    command: >-
      tar -C {{ config_permdir }} -xpf {{ restore_data_file }}
      --overwrite --transform='s,.*/,,' '{{ archive_config_permdir }}/dc-adminep-root-ca.crt'
    args:
      warn: false
    when: check_ca_cert.rc is defined and
          check_ca_cert.rc == 0

# While licences are not enforced, STX offers support for them through the "system license-install"
# command. The licenses are stored in /etc/platform/.license and /opt/platform/config/<version>/.license
# It is good practice to support license restoration, even if they are not enforced.
- name: Check if license exists in backup config permdir (opt/platform/config)
  command: tar -tf {{ restore_data_file }} '{{ archive_platform_conf_path }}/.license'
  register: check_permdir_license
  failed_when: false
  args:
    warn: false

- name: Restore license in config permdir (/opt/platform/config/...)
  command: >-
    tar -C {{ config_permdir }} -xpf {{ restore_data_file }}
    --overwrite --transform='s,.*/,,' '{{ archive_platform_conf_path }}/.license'
  args:
    warn: false
  when: check_permdir_license.rc is defined and
        check_permdir_license.rc == 0

- name: Check if license exists in backup platform config (etc/platform)
  command: tar -tf {{ restore_data_file }} '{{ archive_platform_conf_path }}/.license'
  register: check_platform_license
  failed_when: false
  args:
    warn: false

- name: Restore license in platform config (/etc/platform/)
  command: >-
    tar -C {{ platform_conf_path }} -xpf {{ restore_data_file }}
    --overwrite --transform='s,.*/,,' '{{ archive_platform_conf_path }}/.license'
  args:
    warn: false
  when: check_platform_license.rc is defined and
        check_platform_license.rc == 0

- name: Check if SSH config directory exists in backup tarball
  command: tar -tf {{ restore_data_file }} 'etc/ssh/*'
  register: check_ssh_dir
  failed_when: false
  args:
    warn: false

- block:
  - name: Restore SSH config directory
    command: >-
      tar -C /etc/ssh -xpf {{ restore_data_file }} --overwrite
      --transform='s,.*/,,' etc/ssh/*
    args:
      warn: false

  - block:
    - name: Gather latest SSH public key
      command: ssh-keyscan -T 20 -t ecdsa {{ ssh_hostname }}
      register: remote_keyscan
      until: remote_keyscan.stdout != ""
      retries: 6
      delay: "{{ 3 | random }}"
      delegate_to: localhost

    - name: Update the known_hosts file with collected SSH public keys
      lineinfile:
        path: "~/.ssh/known_hosts"
        create: yes
        line: "{{ item }}"
      with_items: "{{ remote_keyscan.stdout_lines | list }}"
      register: add_sshkey
      until: not add_sshkey.changed
      retries: 6
      delay: "{{ 3 | random }}"
      delegate_to: localhost
    when: inventory_hostname != 'localhost'
  when: check_ssh_dir.rc is defined and check_ssh_dir.rc == 0

# Restore resolv.conf and dnsmaq
- name: Extract resolv.conf from backup tarball
  command: >-
    tar -C /etc -xpf {{ restore_data_file }} --overwrite
    --transform='s,.*/,,' etc/resolv.conf
  args:
    warn: false

- name: Restore resolv.conf in config permdir (/opt/platform/config/...)
  command: >-
    tar -C {{ config_permdir }} -xpf {{ restore_data_file }}
    --overwrite --transform='s,.*/,,' '{{ archive_config_permdir }}/resolv.conf'
  args:
    warn: false

- name: Restore dnsmaq in config permdir (/opt/platform/config/...)
  command: >-
    tar -C {{ config_permdir }} -xpf {{ restore_data_file }}
    --overwrite --transform='s,.*/,,' '{{ archive_config_permdir }}/dnsmasq*'
  args:
    warn: false

- name: Restore boot files in pxelinux.cfg dir
  command: >-
    tar -C {{ pxe_config_permdir }} -xpf {{ restore_data_file }}
    --overwrite --transform='s,.*/,,' '{{ archive_config_permdir }}/pxelinux.cfg/*-*-*'
  args:
    warn: false
  when: migrate_platform_data is not defined or not migrate_platform_data

- name: Extract ldap.db to staging directory
  command: >-
    tar -C {{ staging_dir }} -xpf {{ restore_data_file }}
    --transform='s,.*/,,' '*/ldap.db'
  args:
    warn: false

- name: Stop openldap service
  shell: "export SYSTEMCTL_SKIP_REDIRECT=1; /etc/init.d/openldap stop"

- name: Delete ldap directory
  file:
    path: "{{ ldap_permdir }}"
    state: absent

- name: Recreate ldap directory
  file:
    path: "{{ ldap_permdir }}"
    state: directory
    recurse: yes
    owner: root
    group: root
    mode: 0755

- name: Restore ldap
  shell: slapadd -F /etc/openldap/schema -l {{ staging_dir }}/ldap.db

- name: Start openldap service
  shell: "export SYSTEMCTL_SKIP_REDIRECT=1; /etc/init.d/openldap start"

- name: Delete file from staging dir
  file:
    path: "{{ staging_dir }}/ldap.db"
    state: absent

- name: Restore home directory
  shell: tar -C / --overwrite -xpf {{ restore_data_file }} 'home/*'
  args:
    warn: false
  become_user: root

- name: Restore extension filesystem
  command: tar -C / --overwrite -xpf {{ restore_data_file }} {{ item }}
  args:
    warn: false
  become_user: root
  with_items:
    - "{{ extension_permdir | regex_replace('^\\/', '') }}"

- name: Check if armada folder is present in the backup tarball
  shell: "tar -tf {{ restore_data_file }} | grep '{{ armada_permdir | regex_replace('^\\/', '') }}'"
  args:
    warn: false
  failed_when: false
  register: bkp_has_armada

- name: Restore armada manifests
  command: tar -C / --overwrite -xpf {{ restore_data_file }} {{ item }}
  args:
    warn: false
  become_user: root
  with_items:
    - "{{ armada_permdir | regex_replace('^\\/', '') }}"
  when: bkp_has_armada.rc is defined and
        bkp_has_armada.rc == 0

- name: Check if fluxcd folder is present in the backup tarball
  shell: "tar -tf {{ restore_data_file }} | grep '{{ fluxcd_permdir | regex_replace('^\\/', '') }}'"
  args:
    warn: false
  failed_when: false
  register: bkp_has_fluxcd

- name: Restore fluxcd manifests
  command: tar -C / --overwrite -xpf {{ restore_data_file }} {{ item }}
  args:
    warn: false
  become_user: root
  with_items:
    - "{{ fluxcd_permdir | regex_replace('^\\/', '') }}"
  when: bkp_has_fluxcd.rc is defined and
        bkp_has_fluxcd.rc == 0

- name: Restore helm overrides
  command: tar -C / --overwrite -xpf {{ restore_data_file }} {{ archive_helm_permdir }}
  args:
    warn: false
  become_user: root

- name: Restore sysinv default configuration file
  command: >-
    tar -C {{ sysinv_config_permdir }} -xpf {{ restore_data_file }}
    --transform='s,.*/,,' '*/sysinv.conf.default'
  args:
    warn: false

- name: Restore coredump.conf.d directory
  command: >-
    tar -C /etc/systemd/coredump.conf.d -xpf {{ restore_data_file }}
    --overwrite --transform='s,.*/,,' etc/systemd/coredump.conf.d/*
  args:
    warn: false

- name: Look for the flag indicating that ceph is configured
  shell: "tar -tf {{ restore_data_file }} | grep '{{ archive_ceph_backend_flag }}'"
  args:
    warn: false
  failed_when: false
  register: ceph_backend

# Restore ceph crushmap if ceph backend is configured
- block:
  # Can't store ceph crushmap at sysinv_config_permdir (/opt/platform/sysinv/)
  # for AIO systems because when unlocking controller-0 for the first time,
  # the crushmap is set thru ceph puppet when /opt/platform is not mounted yet.
  # So for AIO systems store the crushmap at /etc/sysinv.
  - name: Set ceph crushmap directory to /etc/sysinv if it is AIO system
    set_fact:
      ceph_crushmap_dir: /etc/sysinv
    when: system_type == 'All-in-one'

  - name: Set ceph crushmap directory to /opt/platform/sysinv if it is non-AIO system
    set_fact:
      ceph_crushmap_dir: "{{ sysinv_config_permdir }}"
    when: system_type != 'All-in-one'

  - name: Restore ceph crush map
    command: >-
      tar -C {{ ceph_crushmap_dir }} -xpf {{ restore_data_file }}
      --transform='s,.*/,,' '*/crushmap.bin.backup'
    args:
      warn: false

  # Need to remove osd info from the crushmap before it is loaded into ceph.
  # When osds are created they will be inserted into the crushmap by ceph.
  # TODO: There might be a better command to do this, like the rebuild option
  # with the ceph-monstore-tool.
  - name: Remove osds from the crushmap
    shell: >-
      crushtool -i {{ ceph_crushmap_dir }}/{{ crushmap_file }} --tree |
      awk /osd/'{print $NF}' |
      xargs -i crushtool -i {{ ceph_crushmap_dir }}/{{ crushmap_file }} --remove-item {}
      -o {{ ceph_crushmap_dir }}/{{ crushmap_file_tmp }} &&
      mv {{ ceph_crushmap_dir }}/{{ crushmap_file_tmp }} {{ ceph_crushmap_dir }}/{{ crushmap_file }}

  when: ceph_backend.rc == 0

- name: Look for deploy files
  shell: "tar -tf {{ restore_data_file }} |
         grep {{ archive_deploy_permdir }}"
  args:
    warn: false
  failed_when: false
  register: deploy_search_result

- name: Restore files in deploy directory (/opt/platform/deploy/...)
  command: >-
    tar -C / --overwrite -xpf {{ restore_data_file }}
    {{ archive_deploy_permdir}}
  args:
    warn: false
  when: deploy_search_result.rc == 0

# TODO: Restore ceph_external when it is supported

- block:
  - name: Check if the system is a DC controller
    command: >-
      grep -i "distributed_cloud_role\s*=\s*systemcontroller"
      {{ platform_conf_path }}/platform.conf
    register: check_dc_controller
    failed_when: false

  - name: Shutdown mtce
    command: /usr/lib/ocf/resource.d/platform/mtcAgent stop
    environment:
      OCF_ROOT: "/usr/lib/ocf"
      OCF_RESKEY_state: "active"

  - name: Stop services
    systemd:
      name: "{{ item }}"
      state: stopped
    with_items:
      - openstack-keystone
      - fminit
      - fm-api
      - sysinv-api
      - sysinv-conductor
      - sysinv-agent
      - openstack-barbican-api

  - name: Stop sysinv-fpga-agent service if it is AIO system
    systemd:
      name: sysinv-fpga-agent
      state: stopped
    when: system_type == 'All-in-one'

  - block:
    - name: Create staging directory for postgres data
      file:
        path: "{{ staging_dir }}/postgres"
        state: directory
        recurse: yes
        owner: root
        group: root
        mode: 0755

    - name: Extract postgres db to staging directory
      command: >-
        tar -C {{ staging_dir }}/postgres -xpf {{ restore_data_file }}
        --transform='s,.*/,,' '*/*\.postgreSql\.*'
      args:
        warn: false

    - name: Restore postgres db
      shell: "psql -f {{ item }} {{ (item|basename).split('.')[0] }}"
      become_user: postgres
      with_items:
        - "{{ staging_dir }}/postgres/postgres.postgreSql.config"
        - "{{ staging_dir }}/postgres/postgres.postgreSql.data"
        - "{{ staging_dir }}/postgres/template1.postgreSql.data"
        - "{{ staging_dir }}/postgres/sysinv.postgreSql.data"
        - "{{ staging_dir }}/postgres/keystone.postgreSql.data"
        - "{{ staging_dir }}/postgres/fm.postgreSql.data"
        - "{{ staging_dir }}/postgres/barbican.postgreSql.data"
        - "{{ staging_dir }}/postgres/helmv2.postgreSql.data"

    - name: Restore postgres db for DC systemcontroller
      shell: "psql -f {{ item }} {{ (item|basename).split('.')[0] }}"
      become_user: postgres
      with_items:
        - "{{ staging_dir }}/postgres/dcmanager.postgreSql.data"
        - "{{ staging_dir }}/postgres/dcorch.postgreSql.data"
      when: check_dc_controller.rc == 0

    - name: Remove postgres staging directory
      file:
        path: "{{ staging_dir }}/postgres"
        state: absent

    when: migrate_platform_data is not defined or not migrate_platform_data

  - block:
    - name: Check if fernet keys directory exists in the backup tarball
      command: tar -tf {{ restore_data_file }} {{ archive_fernet_keys_permdir }}
      register: check_fernet_keys_dir
      failed_when: false
      args:
        warn: false

    - name: Migrate fernet keys
      command: >-
        tar -C {{ fernet_keys_permdir }} -xpf {{ restore_data_file }} --overwrite
        --transform='s,.*/,,' {{ archive_fernet_keys_permdir }}/*
      args:
        warn: false
      when: check_fernet_keys_dir.rc == 0

    - name: Migrate databases and platform data
      command: "upgrade_controller_simplex {{ restore_data_file }}"
      register: migration_output

    - debug:
        var: migration_output.stdout_lines

    when: migrate_platform_data is defined and migrate_platform_data

  # Set all the hosts including controller-0 to locked/disabled/offline state.
  # After the services are restarted, mtce will update controller-0 to
  # locked/disabled/online state. Setting controller-0 to offline state now
  # will ensure that keystone, sysinv and mtcAgent are indeed in-service after being restated.
  - name: Set all the hosts to locked/disabled/offline state
    shell: >-
      psql -c "update i_host set administrative='locked', operational='disabled',
      availability='offline'" sysinv
    become_user: postgres
    when: wipe_ceph_osds|bool and ceph_backend.rc == 0 or ceph_backend.rc != 0

  - name: Set all the hosts, except storage nodes to locked/disabled/offline state
    shell: >-
      psql -c "update i_host set administrative='locked', operational='disabled',
      availability='offline' where personality!='storage'" sysinv
    become_user: postgres
    when: not wipe_ceph_osds|bool and ceph_backend.rc == 0

  # Container images will not be present after restore. Inform sysinv so it
  # can download the images. Kubernetes will then start the apps.
  - name: Set applied apps to "restore-requested" state
    shell: psql -c "update kube_app set status='restore-requested' where status='applied'" sysinv
    become_user: postgres

  - name: Restart services
    systemd:
      name: "{{ item }}"
      state: restarted
    with_items:
      - openstack-keystone
      - fminit
      - fm-api
      - sysinv-api
      - sysinv-conductor
      - sysinv-agent
      - openstack-barbican-api

  - name: Restart sysinv-fpga-agent service if it is AIO system
    systemd:
      name: sysinv-fpga-agent
      state: restarted
    when: system_type == 'All-in-one'

  - name: Bring up Maintenance Agent
    command: /usr/lib/ocf/resource.d/platform/mtcAgent start
    environment:
      OCF_ROOT: "/usr/lib/ocf"
      OCF_RESKEY_state: "active"

  - name: Wait for 90 secs before check if services come up
    wait_for: timeout=90

  # admin-keystone is always the very last to be ready,
  # So we just wait and check for admin-keystone to come up.
  - name: Make sure admin-keystone is ready
    shell: "ps -ef | grep admin-keystone | grep -v grep"
    register: result
    until: result.stdout.find("keystone") != -1
    retries: 6
    delay: 10

  # Run "system host-list" to verify that controller-0 is in
  # "online" state. This will ensure that keystone, sysinv and
  # mtcAgent are indeed in-service after being restated.
  - name: Check controller-0 is in online state
    shell: source /etc/platform/openrc; system host-show controller-0 --column availability --format value
    register: check_online
    failed_when: false
    retries: 30
    delay: 10
    until: check_online.stdout == "online"

  - name: Inform user that restore_platform is not successful
    debug:
      msg: >-
        Platform restore was unsuccessful. Please refer to the system administration
        guide for next step.
    when: check_online.stdout != "online"

  - name: Check if there are unprovisioned hosts
    shell: source /etc/platform/openrc; system host-list --format value --column personality --column id
    register: ids_and_personalities

  - name: Delete unprovisioned hosts
    shell: source /etc/platform/openrc; system host-delete {{ item.split(' ')[0] }}
    loop: "{{ ids_and_personalities.stdout_lines }}"
    when: (item.split(' ')[1] | lower) == 'none'

  # Restore ceph-mon data if ceph backend is configured
  - block:
    - block:
      # Recover procedure for systems with storage nodes is different from
      # that of systems with controller storage:
      # - For controller storage we recover ceph-mon data by scanning OSDs.
      # - For systems with storage nodes we get ceph-mon data from storage-0
      #   ceph-mon that is already up and will not be reinstalled.
      - name: Check if setup has storage nodes
        shell: source /etc/platform/openrc; system host-list --format value --column personality
        register: node_personalities
        failed_when: false

      # Get system_mode after restore and create flag file to skip wiping OSDs
      - name: Retrieve system mode
        shell: source /etc/platform/platform.conf; echo $system_mode
        register: restore_system_mode_result

      - name: Fail if system mode is not defined
        fail:
          msg: "system_mode is missing in /etc/platform/platform.conf"
        when: restore_system_mode_result.stdout_lines|length == 0

      - name: Set system mode fact
        set_fact:
          restore_system_mode: "{{ restore_system_mode_result.stdout_lines[0] }}"

      - name: Create flag file in /etc/platform to skip wiping OSDs
        file:
          path: "{{ skip_ceph_osds_wipe_flag }}"
          state: touch
        when: restore_system_mode != 'simplex'

      # Recover ceph data for systems with controller storage
      - include_role:
          name: recover-ceph-data
        when: node_personalities.stdout is not search('storage')

      - name: Mark crushmap as restored
        file:
          path: "{{ sysinv_config_permdir }}/.crushmap_applied"
          owner: root
          group: root
          mode: 644
          state: touch

      when: not wipe_ceph_osds|bool

    when: check_online.stdout == "online" and ceph_backend.rc == 0

  - name: Apply kube-apiserver parameters
    block:
    - name: Update host config data
      command: "/usr/bin/sysinv-puppet create-host-config"

    - name: Update system config data
      command: "/usr/bin/sysinv-puppet create-system-config"

    - name: Create a list of apiserver parameters classes to pass to puppet
      copy:
        dest: "/tmp/apiserver.yml"
        content: |
          classes:
          - platform::kubernetes::master::change_apiserver_parameters

    - name: Apply puppet apiserver parameters
      command: >
        /usr/local/bin/puppet-manifest-apply.sh
        {{ puppet_permdir }}/hieradata/
        {{ derived_network_params.controller_0_address }}
        controller runtime /tmp/apiserver.yml
      environment:
        LC_ALL: "en_US.UTF-8"

  - name: Set restore in progress for sysinv
    shell: "source /etc/platform/openrc; system restore-start"

  - name: Inform user that restore_platform is run successfully
    debug:
      msg: >-
        Controller-0 is now online. The next step is to unlock this controller.
        Please refer to the system administration guide for more details.
    when: check_online.stdout == "online"

  # Remove temporary staging area used by the copy module
  - name: Remove temporary directory used to stage restore data
    file:
      path: "{{ ansible_remote_tmp }}"
      state: absent
